
# Relaciones Entre Modelos en Django

En proyectos reales, rara vez trabajarás con modelos aislados. Las relaciones permiten conectar modelos entre sí, tal como funcionan las tablas en bases de datos relacionales.

Django ofrece tres tipos principales de relaciones:

* **OneToOneField**
* **ForeignKey** (uno a muchos)
* **ManyToManyField**

A continuación se explican en profundidad.

---

## Relación One-to-One (Uno a Uno)

Una relación uno a uno significa que un registro de un modelo está relacionado con **exactamente un registro** de otro modelo, y al revés.

Es muy útil cuando quieres **extender** un modelo ya existente sin modificarlo, por ejemplo, ampliar el modelo `User` de Django con más información.

Ejemplo:

```python
class Perfil(models.Model):
    usuario = models.OneToOneField(User, on_delete=models.CASCADE)
    biografia = models.TextField()
```

### Detalles importantes:

* Django crea una **restricción de unicidad**: un usuario no puede tener dos perfiles.
* La relación se guarda internamente como una clave única.
* Si se elimina el objeto relacionado (aquí `User`), el perfil también se elimina porque se usa `on_delete=models.CASCADE`.
* Permite acceder en ambos sentidos:

  * `perfil.usuario`
  * `usuario.perfil` (Django crea un atributo automáticamente, o puedes definirlo con `related_name`).

---

## Relación One-to-Many (Uno a Muchos) – ForeignKey

Se usa cuando un objeto pertenece a otro, pero el segundo puede tener muchos relacionados.

Ejemplo típico:
Un autor puede tener muchos libros, pero cada libro solo tiene un autor.

```python
class Autor(models.Model):
    nombre = models.CharField(max_length=50)

class Libro(models.Model):
    titulo = models.CharField(max_length=100)
    autor = models.ForeignKey(Autor, on_delete=models.CASCADE)
```

### Detalles importantes:

* Esta relación se representa mediante una **clave foránea** en la tabla "muchos" (libros).
* `on_delete` determina qué sucede si el autor se elimina:

  * `CASCADE`: se eliminan también los libros.
  * `SET_NULL`: se mantiene el libro pero con el autor vacío → requiere `null=True`.
  * `PROTECT`: impide eliminar si tiene libros asociados.
  * `SET_DEFAULT`: sustituye por un valor por defecto.
* Se puede acceder en ambos sentidos:

  * Desde un libro: `libro.autor`
  * Desde un autor, Django genera: `autor.libro_set.all()`

    * Se puede cambiar el nombre con `related_name="libros"`.

---

## Relación Many-to-Many (Muchos a Muchos)

Se utiliza cuando **muchos** elementos del modelo A pueden estar relacionados con **muchos** elementos del modelo B.

Ejemplo: estudiantes y cursos.

```python
class Curso(models.Model):
    nombre = models.CharField(max_length=100)

class Estudiante(models.Model):
    nombre = models.CharField(max_length=100)
    cursos = models.ManyToManyField(Curso)
```

### ¿Qué sucede internamente?

Django crea automáticamente una **tabla intermedia** con dos columnas:

* `estudiante_id`
* `curso_id`

Cada fila representa una relación.

### Características de Many-to-Many:

* Una instancia puede tener múltiples objetos relacionados.
* Pueden modificarse las relaciones sin tocar los modelos.
* Accesos bidireccionales:

  * `estudiante.cursos.all()`
  * `curso.estudiante_set.all()`
* Es posible personalizar la tabla intermedia si necesitas guardar más información sobre la relación, por ejemplo, fecha de inscripción o nota obtenida:

```python
class Matricula(models.Model):
    estudiante = models.ForeignKey(Estudiante, on_delete=models.CASCADE)
    curso = models.ForeignKey(Curso, on_delete=models.CASCADE)
    fecha = models.DateField()
    nota = models.DecimalField(max_digits=4, decimal_places=2)

class Estudiante(models.Model):
    nombre = models.CharField(max_length=100)
    cursos = models.ManyToManyField(Curso, through='Matricula')
```

Con esto se tiene un control total sobre la relación, convirtiéndola en un modelo explícito.



# Explicación Detallada del Modelo `Matricula` y la Relación Many-to-Many Personalizada

En Django, una relación Many-to-Many básica como:

```python
cursos = models.ManyToManyField(Curso)
```

crea automáticamente una tabla intermedia con solo dos columnas:

* `estudiante_id`
* `curso_id`

Pero **cuando necesitamos guardar más información sobre esa relación**, este esquema se queda corto.

Por ejemplo:

* fecha de matriculación
* calificación obtenida
* grupo
* asistencia
* número de expediente
* modalidad (online/presencial)

En estos casos, el ManyToMany automático no sirve, y debemos crear una **tabla intermedia explícita**, como `Matricula`.

---

# ¿Qué hace exactamente la clase `Matricula`?

```python
class Matricula(models.Model):
    estudiante = models.ForeignKey(Estudiante, on_delete=models.CASCADE)
    curso = models.ForeignKey(Curso, on_delete=models.CASCADE)
    fecha = models.DateField()
    nota = models.DecimalField(max_digits=4, decimal_places=2)
```

### Función principal

`Matricula` representa una **instancia concreta de relación** entre un estudiante y un curso.
Cada fila de esta tabla corresponde a:

> Un estudiante matriculado en un curso, en una fecha concreta y con una nota concreta.

Es decir:
No representa al estudiante.
No representa al curso.
Representa la **relación entre ambos** con atributos propios.

---

# ¿Por qué hay dos ForeignKey?

* `estudiante = models.ForeignKey(Estudiante)`
  Indica a qué estudiante pertenece esta matrícula.

* `curso = models.ForeignKey(Curso)`
  Indica en qué curso está matriculado.

Ambas claves forman la relación.

Esto es lo que convierte a `Matricula` en la **tabla puente**.

---

# ¿Qué aporta el `through='Matricula'`?

```python
cursos = models.ManyToManyField(Curso, through='Matricula')
```

### Significa:

“No uses la tabla many-to-many automática.
En su lugar, usa mi tabla definida manualmente, llamada `Matricula`.”

Django entonces:

* No crea su tabla intermediaria automática.
* Sabe llegar del estudiante a sus cursos pasando por `Matricula`.
* Sabe llegar del curso a sus estudiantes pasando por `Matricula`.
* Permite que consultemos y creemos relaciones usando el modelo intermedio.

---

# ¿Se puede usar `.add()` con ManyToMany?

No, **queda deshabilitado** cuando se usa `through`.

Ejemplo que *NO funciona*:

```python
estudiante.cursos.add(curso)
```

Esto fallará porque Django no sabe qué poner en los campos extra (`fecha`, `nota`).

Debes crear instancias de `Matricula` manualmente:

```python
Matricula.objects.create(
    estudiante=estudiante,
    curso=curso,
    fecha=date.today(),
    nota=8.5
)
```

---

# Cómo acceder a la información

## Obtener los cursos de un estudiante

```python
estudiante.cursos.all()
```

Esta consulta sigue funcionando porque Django sabe usar la tabla `Matricula`.

## Obtener los estudiantes de un curso

```python
curso.estudiante_set.all()
```

A menos que definas `related_name` en Matricula, el nombre por defecto será `estudiante_set`.

## Obtener información de la matrícula (la relación en sí)

Esto es lo más interesante:

```python
Matricula.objects.filter(estudiante=estudiante)
```

Devuelve todas las relaciones de ese estudiante con sus cursos, incluyendo fecha y nota.

Ejemplo de uso real:

```python
for m in Matricula.objects.filter(estudiante=estudiante):
    print(m.curso.nombre, m.fecha, m.nota)
```

---

# Añadiendo restricciones: evitar matrículas duplicadas

Una mejora común es evitar que un mismo estudiante se matricule varias veces en el mismo curso:

```python
class Meta:
    unique_together = ('estudiante', 'curso')
```

Esto convierte la pareja (estudiante, curso) en única.

---

# Beneficios pedagógicos y prácticos

### 1. Representa situaciones reales

La mayoría de relaciones N:N en la vida real tienen datos adicionales:
alumnos–asignaturas, pedidos–productos, reservas–clases, autores–libros…

### 2. Flexibilidad total

Puedes añadir datos a la relación sin modificar los modelos principales.

### 3. Control total sobre la tabla intermedia

Puedes definir:

* validaciones
* métodos propios
* restricciones de unicidad
* acciones al eliminar objetos relacionados

### 4. El código refleja mejor el dominio del problema

En una aplicación educativa, tener un modelo explícito `Matricula` facilita la comprensión de cómo funcionan los datos.

---

# Ejemplo ampliado con `related_name` y `verbose_name`

Para que todo sea más claro:

```python
class Matricula(models.Model):
    estudiante = models.ForeignKey(
        Estudiante,
        on_delete=models.CASCADE,
        related_name='matriculas'
    )
    curso = models.ForeignKey(
        Curso,
        on_delete=models.CASCADE,
        related_name='matriculas'
    )
    fecha = models.DateField()
    nota = models.DecimalField(max_digits=4, decimal_places=2)

    class Meta:
        unique_together = ('estudiante', 'curso')

    def __str__(self):
        return f"{self.estudiante} en {self.curso}"
```

Ahora podemos hacer:

```python
estudiante.matriculas.all()
curso.matriculas.all()
```

De esta manera accedemos a la **relación completa**, no solo al curso o al estudiante.







